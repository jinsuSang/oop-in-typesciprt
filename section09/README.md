# 상속 vs 컴포지션

## OO에서 재사용성을 중요시하는 이유

> 바퀴를 다시 발명하시 마라

### 1. 설계와 코딩에 드는 시간을 절약

- 설계 및 코딩을 다시 할 필요가 없음
- OO 외의 프로그래밍에도 적용되는 올바른 원칙
- 실전에서 100% 적용 불가
- 미래에 어떻게 변할지 예측 불가
- 재사용성에만 집중하여 잘못된 바퀴를 장착할 수 있음

### 2. 테스트에 걸리는 시간을 절약

- 이미 테스트까지 끝낸 클래스를 다시 테스트할 필요가 없음
- 상속 시 부모 클래스는 이미 테스트가 끝난 상황
- 부모 클래스를 테스트할 필요가 없다

#### 실제로는 그렇지 않음

- 새로운 방법으로 부모 클래스 사용
  - 자식 클래스에서 부모 클래스를 다른 방식으로 사용할 수 있음
  - 새로운 버그 발견 가능
- 부모 클래스를 변경
  - 구체적인 것을 먼저 보고 추상화 한다
  - 새로운 자식 클래스가 상속받을 수 있도록 수정할 수 있다

### 관리 비용 절약

- 코드 중복이 없음
  - 따라서 한 곳만 고치고 다른 곳을 실수로 안 고칠 가능성이 없음
- 관련된 코드가 모두 한 파일 안에 있음
  - 따라서 그 파일을 열어 모든 로직 및 데이터 파악 가능
  - 재사용성을 위해 클래스를 잘게 나누면 파일이 많아짐

#### 재사용성과 유지/관리 사이의 밸런스가 중요하다

> 실버 불렛은 없다 - 프레더릭 브룩스

## 상속 VS 컴포지션 선택 4가지 기준

- 상속과 컴포지션 모두 재사용성이 목적

### 1. 상속 VS 컴포지션 메모리

- 기계상의 차이 때문에 하나를 골라야 할 때

#### 상속과 메모리

- 개체 생성시 메모리가 하나의 덩어리

#### 컴포지션과 메모리

- 개체 생성시 메모리가 여러 덩어리

#### 메모리 상의 차이는 실행 성능에 영향을 미침

#### 프로그램 실행 중 첫 번째 병목점

- CPU와 메모리 사이의 데이터 전송
- CPU에 고속 캐시 매모리를 탑재해 해결

##### 상속 모델로 만든 개체

- 개체가 한 번에 캐시 메모리에 들어갈 가능성이 높음

##### 컴포지션 모델로 만든 개체

- 개체 내 부품 수 만큼 캐시 메모리로 로딩할 가능성이 높음

#### 프로그램 실행 중 두 번째 병목점

- 새로운 메모리 할당과 해제
- 프로그래밍 언어에 따라 특히 느린 것이 있음
- 상속은 메모리 할당과 해제가 딱 한 번씩
- 컴포지션은 한 번 + 부품 수만큼씩

### 2. 상속 VS 컴포지션 다형성

- 용도 때문에 상속을 고를 수 밖에 없을 때

### 3. 상속 VS 컴포지션 유지보수

- 관리의 효율성을 고려할 때

#### 상속이 더 나은 상황

- 컴포지션 모델을 사용할 때 부모 클래스 메서드를 호출이 필요해서 릴레이 함수를 만드는 경우
- 상속 사용시 자식 클래스는 부모의 매서드를 호출 가능

#### 컴포지션이 더 나은 상황

- 깊은 상속 관계
- 상위 클래스 변경시 하위 클래스들을 모두 점검해야 함
- 컴포지션도 비슷한 문제가 있지만 상속보다는 덜함
- 컴포지션은 조립성을 더 강조했기 때문
